even (fn [x]
  (:: Int Bool)
  (= 0 (rem 2 x)))

_ (even -6)

odd (fn [x]
  (:: Int Bool)
  (not (even x)))

_ (odd -3)

id (fn [x] (:: a a) x)

_ (= 7 (id 7))

const (fn [x y] (:: a b a) x)

_ (= 8 (const 8 2))

. (fn [second first]
  (:: (Fn b c) (Fn a b) a c)
  (fn [x] (second (first x))))

_ (= 42 ((. (* 7) (+ 5)) 1))

fst (fn [tuple]
  x
  {x y} tuple)

_ (= 1 (fst {1 2}))

snd (fn [tuple]
  y
  {x y} tuple)

_ (= 2 (snd {1 2}))

curry (fn [fun x y]
  (fun {x y}))

_ (= 1 ((curry fst) 1 2))

uncurry (fn [fun tuple]
  (fun x y)
  {x y} tuple)

_ (= 3 ((uncurry +) {1 2}))

until (fn [cond fun input]
  (if (cond input)
    input
    (until cond fun (fun input))))

_ (= 21 (until (. (= 0)(rem 7)) (+ 1) 15))

map (fn [fun list]
  (match list
    [] list
    [x ..xs] (& (fun x) (map fun xs))))

_ (= [3 4 5] (map (+ 2) [1 2 3]))

join (fn [onto what]
  (match onto
    [] what
    [x ..xs] (& x (join xs what))))

_ (= [3 4 5] (join [3] [4 5]))

filter (fn [cond list]
  (:: (a Bool) (Sequence a))
  (match list
    [] list
    [x ..xs] (if (cond x)
      (& x (filter cond xs))
      (filter cond xs))))

_ (= [2] (filter even [1 2 3]))

fold (fn [fun initial list]
  (:: (a b b) b (List a) b)
  (match list
    [] initial
    [x ..xs] (fun x (fold fun initial xs))))

_ (= 24 (fold * 1 [2 3 4]))

reduce (fn [fun initial list]
  (:: (b a b) b (List a) b)
  (match list
    [] initial
    [x ..xs] (reduce fun (fun initial x) xs)))

concat (fn [lists]
  (:: [(a (b c)) (b c)]
    [(Seq a) (Seq b)])
  (fold join (empty (at 0 lists)) lists))

_ (# (= [1 2 3 4] (concat [[1 2] [3 4]])))

head (fn [list]
  x
  [x ..xs] list)

_ (= 1 (head [1 2 3]))

tail (fn [list]
  xs
  [x ..xs] list)

_ (= [2 3] (head [1 2 3]))

length (fn [list]
  (match list
    [] 0
    [x ..xs] (+ 1 (length xs))))

_ (= 3 (length [1 2 3]))

at (fn [index list]
  (:: n (List a) a)
  (match index
    0 (head list)
    n (at (- 1 n) (tail list))))

_ (= 3 (at 2 [1 2 3 4]))

take (fn [quantity list]
  (if (<= 0 quantity)
    (empty list)
    (match list
      [] list
      [x ..xs] (& x (take (- 1 quantity) xs)))))

_ (= [1 2] (take 2 [1 2 3 4]))

drop (fn [quantity list]
  (if (<= 0 quantity)
    list
    (match list
      [] list
      [x ..xs] (drop (- 1 quantity) xs))))

map2 (fn [fun list]
  (fold mapHelper [] list)
  mapHelper (fn [result x]
    (& (fun x) result)))

add2 (+ 2)

mapping (fn [fun reducer input result]
  (reducer (fun input) result))

filtering (fn [cond reducer input result]
  (if (cond input)
    (reducer input result)
    result))

sequence (fn [transducer list]
  (fold (transducer &) "" list ))

sequenceMap (# (fn [transducer list]
  (foldKeys (fn [key val r]
      (transducer (put key) val r)) (empty {:x 1}) list)))

append (fn [what to]
  (join to (& what (empty to))))

prepend (fn [x list]
  (& x list))

range (fn [from exclude-to]
  (if (= from exclude-to)
    (list)
    (& from (range (+ from 1) exclude-to))))

sum (fold + 0)
