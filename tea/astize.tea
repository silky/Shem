[const fold reduce map append length at drop either id concat join] (require Tea.Prelude [const fold reduce map append length at drop either id concat join])
[sieve-ok] (require Tea.Good [sieve-ok])
[tokenize] (require Compiler.Tokenize [tokenize])

S-Expression (data
  {:list (List S-Expression)}
  {:atom Token})

astize (fn [tokens]
  (:: (List Token) (Either S-Expression AstError))
  (sieve-ok validate-stack (attempt-astize tokens)))

attempt-astize (fn [tokens]
  (reduce maybe-astize-token initial-stack tokens)
  initial-stack {:good (list {:list []})})

maybe-astize-token (fn [stack-or-error token]
  (:: Stack Token Stack)
  (sieve-ok (astize-token token) stack-or-error))

Stack (type
  (GoodOrBad (List S-Expression)))

astize-token (fn [token stack]
  (:: Token Stack Stack)
  (match (token-type token)
    ;open-paren {:good (& (list-append atom []) stack)}
    ;closed-paren (match rest-stack
      [] {:bad {"Unexpected closing paren" (token-pos token)}}
      [{:list parent-list} ..prev-stack] {:good
        (& (list-append (list-append atom open-list) parent-list) prev-stack)})
    _ {:good (& (list-append atom open-list) rest-stack)})
  atom {:atom token}
  [{:list open-list} ..rest-stack] stack
  list-append (fn [expression onto]
    {:list (append expression onto)}))

validate-stack (fn [stack]
  (if (> 1 (length stack))
    {:bad (missing-delim expression)}
    {:good expression})
  [expression .._] stack)

token-type (fn [token]
  kind
  {kind _ _} token)

token-pos (fn [token]
  pos
  {_ _ pos} token)

missing-delim (fn [expression] {
    (join "Missing matching " (delim-name (token-type head-token)))
    (token-pos head-token)}
  {:list [{:atom head-token} ..open-list]} expression)

delim-name (fn [token-type]
  (match token-type
    ;open-paren "paren"
    ;open-bracket "bracket"))